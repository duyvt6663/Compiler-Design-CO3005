# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *
import numpy as np
import os 
import sys
if not '.././main/mt22/checker/' in sys.path:
    sys.path.append('.././main/mt22/checker/')
if not '.././main/mt22/utils/' in sys.path:
    sys.path.append('.././main/mt22/utils/')
from TypeCheck import *
from functools import *

from lexererr import *
charset_0 = list(chain(range(49, 58)))
charset_1 = list(chain(range(101, 102), range(69, 70)))
charset_2 = list(chain(range(43, 44), range(45, 46)))
charset_3 = list(chain(range(48, 58)))
charset_4 = list(chain(*multirange_diff(printable_unicode_ranges, [(10, 11),(34, 35),(92, 93)])))
charset_5 = list(chain(*multirange_diff(printable_unicode_ranges, [(34, 35),(39, 40),(92, 93),(98, 99),(102, 103),(110, 111),(114, 115),(116, 117)])))
charset_6 = list(chain(range(97, 123), range(65, 91), range(95, 96)))
charset_7 = list(chain(range(97, 123), range(65, 91), range(48, 58), range(95, 96)))
charset_8 = list(chain(range(32, 33), range(9, 10), range(13, 14), range(10, 11)))
charset_9 = list(chain(range(97,102)))


class MT22UnlexerChecker(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(MT22UnlexerChecker, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown
        self.vstack = [{}]
        self.fstack = {
                "readInteger": FuncType([], IntegerType()),
                "printInteger": FuncType([ParamType(IntegerType())], VoidType()),
                "readFloat": FuncType([], FloatType()),
                "printFloat": FuncType([ParamType(FloatType())], VoidType()),
                "readBoolean": FuncType([], BooleanType()),
                "printBoolean": FuncType([ParamType(BooleanType())], VoidType()),
                "readString": FuncType([], StringType()),
                "printString": FuncType([ParamType(StringType())], VoidType()),
                "super": FuncType([], VoidType()),
                "preventDefault": FuncType([], VoidType()), 
                "foo": FuncType([ParamType(IntegerType(), True, True, "a"), 
                                 ParamType(StringType(), True, True, "b")], VoidType()),
                "bar": FuncType([ParamType(IntegerType(), True, True, "x"), 
                                 ParamType(BooleanType(), True, True, "y")], IntegerType())
            }
    
    def addvar(self, key, val):
        self.vstack[-1][key] = val
    def getvar(self, key, getAll:bool = False):
        if getAll is True:
            for tab in self.vstack[::-1]:
                if tab.get(key) is not None:
                    return tab[key]
            return None
        if self.vstack[-1].get(key) is not None:
            return self.vstack[-1][key]
        return None
    def addfun(self, key, val):
        self.fstack[key] = val
    def getfun(self, key):
        if self.fstack.get(key) is not None:
            return self.fstack[key]
        return None

    def EOF(self, *args, **kwargs):
        pass

    def betLessThan(self, threshold):
        # threshold from 0 -> 1
        throw = np.random.rand()
        return True if throw < threshold else False
    
    @depthcontrol
    def INTEGER(self):
        current = self.create_node(UnlexerRule(name='INTEGER'))
        current += self.create_node(UnlexerRule(src='integer'))
        return current
    INTEGER.min_depth = 0

    @depthcontrol
    def FLOAT(self):
        current = self.create_node(UnlexerRule(name='FLOAT'))
        current += self.create_node(UnlexerRule(src='float'))
        return current
    FLOAT.min_depth = 0

    @depthcontrol
    def BOOLEAN(self):
        current = self.create_node(UnlexerRule(name='BOOLEAN'))
        current += self.create_node(UnlexerRule(src='boolean'))
        return current
    BOOLEAN.min_depth = 0

    @depthcontrol
    def STRING(self):
        current = self.create_node(UnlexerRule(name='STRING'))
        current += self.create_node(UnlexerRule(src='string'))
        return current
    STRING.min_depth = 0

    @depthcontrol
    def ARRAY(self):
        current = self.create_node(UnlexerRule(name='ARRAY'))
        current += self.create_node(UnlexerRule(src='array'))
        return current
    ARRAY.min_depth = 0

    @depthcontrol
    def AUTO(self):
        current = self.create_node(UnlexerRule(name='AUTO'))
        current += self.create_node(UnlexerRule(src='auto'))
        return current
    AUTO.min_depth = 0

    @depthcontrol
    def VOID(self):
        current = self.create_node(UnlexerRule(name='VOID'))
        current += self.create_node(UnlexerRule(src='void'))
        return current
    VOID.min_depth = 0

    @depthcontrol
    def INTLIT(self):
        current = self.create_node(UnlexerRule(name='INTLIT'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_8', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_8', choice)] = self.unlexer.weights.get(('alt_8', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='0'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(charset_0)))
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.DEC()

            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.create_node(UnlexerRule(src='_'))
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.unlexer.DEC()


            # self.text = self.text.replace("_","")
        return current
    INTLIT.min_depth = 0

    @depthcontrol
    def FLOATLIT(self):
        current = self.create_node(UnlexerRule(name='FLOATLIT'))
        choice = self.choice([0 if [2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_16', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_16', choice)] = self.unlexer.weights.get(('alt_16', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.INTLIT()
            current += self.unlexer.DECPART()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.EXPOPART()

        elif choice == 1:
            current += self.unlexer.INTLIT()
            current += self.unlexer.EXPOPART()
        elif choice == 2:
            current += self.unlexer.DECPART()
            current += self.unlexer.EXPOPART()
        # self.text = self.text.replace("_","")
        return current
    FLOATLIT.min_depth = 2

    @depthcontrol
    def DECPART(self):
        current = self.create_node(UnlexerRule(name='DECPART'))
        current += self.unlexer.DOT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.DEC()

        return current
    DECPART.min_depth = 1

    @depthcontrol
    def EXPOPART(self):
        current = self.create_node(UnlexerRule(name='EXPOPART'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_1)))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_2)))

        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.DEC()

        return current
    EXPOPART.min_depth = 1

    @depthcontrol
    def DEC(self):
        current = self.create_node(UnlexerRule(name='DEC'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_3)))
        return current
    DEC.min_depth = 0

    @depthcontrol
    def BOOLLIT(self):
        current = self.create_node(UnlexerRule(name='BOOLLIT'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_24', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_24', choice)] = self.unlexer.weights.get(('alt_24', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.TRue()
        elif choice == 1:
            current += self.unlexer.FAlse()
        return current
    BOOLLIT.min_depth = 1

    @depthcontrol
    def STRLIT(self):
        current = self.create_node(UnlexerRule(name='STRLIT'))
        current += self.create_node(UnlexerRule(src='"'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_29', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_29', choice)] = self.unlexer.weights.get(('alt_29', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.STR_CHAR()
                elif choice == 1:
                    current += self.unlexer.ESCSEQ()

        current += self.create_node(UnlexerRule(src='"'))
        
        	# content = str(self.text) 
        	# self.text = content[1:-1]
        return current
    STRLIT.min_depth = 0

    @depthcontrol
    def BlockComment(self):
        current = self.create_node(UnlexerRule(name='BlockComment'))
        current += self.create_node(UnlexerRule(src='/*'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='*/'))
        return current
    BlockComment.min_depth = 0

    @depthcontrol
    def LineComment(self):
        current = self.create_node(UnlexerRule(name='LineComment'))
        current += self.create_node(UnlexerRule(src='//'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='\n'))
        return current
    LineComment.min_depth = 0

    @depthcontrol
    def Function(self):
        current = self.create_node(UnlexerRule(name='Function'))
        current += self.create_node(UnlexerRule(src='function'))
        return current
    Function.min_depth = 0

    @depthcontrol
    def Break(self):
        current = self.create_node(UnlexerRule(name='Break'))
        current += self.create_node(UnlexerRule(src='break'))
        return current
    Break.min_depth = 0

    @depthcontrol
    def Continue(self):
        current = self.create_node(UnlexerRule(name='Continue'))
        current += self.create_node(UnlexerRule(src='continue'))
        return current
    Continue.min_depth = 0

    @depthcontrol
    def If(self):
        current = self.create_node(UnlexerRule(name='If'))
        current += self.create_node(UnlexerRule(src='if'))
        return current
    If.min_depth = 0

    @depthcontrol
    def Else(self):
        current = self.create_node(UnlexerRule(name='Else'))
        current += self.create_node(UnlexerRule(src='else'))
        return current
    Else.min_depth = 0

    @depthcontrol
    def For(self):
        current = self.create_node(UnlexerRule(name='For'))
        current += self.create_node(UnlexerRule(src='for'))
        return current
    For.min_depth = 0

    @depthcontrol
    def While(self):
        current = self.create_node(UnlexerRule(name='While'))
        current += self.create_node(UnlexerRule(src='while'))
        return current
    While.min_depth = 0

    @depthcontrol
    def Return(self):
        current = self.create_node(UnlexerRule(name='Return'))
        current += self.create_node(UnlexerRule(src='return'))
        return current
    Return.min_depth = 0

    @depthcontrol
    def Of(self):
        current = self.create_node(UnlexerRule(name='Of'))
        current += self.create_node(UnlexerRule(src='of'))
        return current
    Of.min_depth = 0

    @depthcontrol
    def Do(self):
        current = self.create_node(UnlexerRule(name='Do'))
        current += self.create_node(UnlexerRule(src='do'))
        return current
    Do.min_depth = 0

    @depthcontrol
    def Out(self):
        current = self.create_node(UnlexerRule(name='Out'))
        current += self.create_node(UnlexerRule(src='out'))
        return current
    Out.min_depth = 0

    @depthcontrol
    def Inherit(self):
        current = self.create_node(UnlexerRule(name='Inherit'))
        current += self.create_node(UnlexerRule(src='inherit'))
        return current
    Inherit.min_depth = 0

    @depthcontrol
    def TRue(self):
        current = self.create_node(UnlexerRule(name='TRue'))
        current += self.create_node(UnlexerRule(src='true'))
        return current
    TRue.min_depth = 0

    @depthcontrol
    def FAlse(self):
        current = self.create_node(UnlexerRule(name='FAlse'))
        current += self.create_node(UnlexerRule(src='false'))
        return current
    FAlse.min_depth = 0

    @depthcontrol
    def LNOT(self):
        current = self.create_node(UnlexerRule(name='LNOT'))
        current += self.create_node(UnlexerRule(src='!'))
        return current
    LNOT.min_depth = 0

    @depthcontrol
    def LAND(self):
        current = self.create_node(UnlexerRule(name='LAND'))
        current += self.create_node(UnlexerRule(src='&&'))
        return current
    LAND.min_depth = 0

    @depthcontrol
    def LOR(self):
        current = self.create_node(UnlexerRule(name='LOR'))
        current += self.create_node(UnlexerRule(src='||'))
        return current
    LOR.min_depth = 0

    @depthcontrol
    def EQUAL(self):
        current = self.create_node(UnlexerRule(name='EQUAL'))
        current += self.create_node(UnlexerRule(src='=='))
        return current
    EQUAL.min_depth = 0

    @depthcontrol
    def NEQ(self):
        current = self.create_node(UnlexerRule(name='NEQ'))
        current += self.create_node(UnlexerRule(src='!='))
        return current
    NEQ.min_depth = 0

    @depthcontrol
    def ADD(self):
        current = self.create_node(UnlexerRule(name='ADD'))
        current += self.create_node(UnlexerRule(src='+'))
        return current
    ADD.min_depth = 0

    @depthcontrol
    def SUB(self):
        current = self.create_node(UnlexerRule(name='SUB'))
        current += self.create_node(UnlexerRule(src='-'))
        return current
    SUB.min_depth = 0

    @depthcontrol
    def MUL(self):
        current = self.create_node(UnlexerRule(name='MUL'))
        current += self.create_node(UnlexerRule(src='*'))
        return current
    MUL.min_depth = 0

    @depthcontrol
    def DIV(self):
        current = self.create_node(UnlexerRule(name='DIV'))
        current += self.create_node(UnlexerRule(src='/'))
        return current
    DIV.min_depth = 0

    @depthcontrol
    def MOD(self):
        current = self.create_node(UnlexerRule(name='MOD'))
        current += self.create_node(UnlexerRule(src='%'))
        return current
    MOD.min_depth = 0

    @depthcontrol
    def GRE(self):
        current = self.create_node(UnlexerRule(name='GRE'))
        current += self.create_node(UnlexerRule(src='>'))
        return current
    GRE.min_depth = 0

    @depthcontrol
    def GEQ(self):
        current = self.create_node(UnlexerRule(name='GEQ'))
        current += self.create_node(UnlexerRule(src='>='))
        return current
    GEQ.min_depth = 0

    @depthcontrol
    def LES(self):
        current = self.create_node(UnlexerRule(name='LES'))
        current += self.create_node(UnlexerRule(src='<'))
        return current
    LES.min_depth = 0

    @depthcontrol
    def LEQ(self):
        current = self.create_node(UnlexerRule(name='LEQ'))
        current += self.create_node(UnlexerRule(src='<='))
        return current
    LEQ.min_depth = 0

    @depthcontrol
    def CONCAT(self):
        current = self.create_node(UnlexerRule(name='CONCAT'))
        current += self.create_node(UnlexerRule(src='::'))
        return current
    CONCAT.min_depth = 0

    @depthcontrol
    def ASSIGN(self):
        current = self.create_node(UnlexerRule(name='ASSIGN'))
        current += self.create_node(UnlexerRule(src='='))
        return current
    ASSIGN.min_depth = 0

    @depthcontrol
    def LB(self):
        current = self.create_node(UnlexerRule(name='LB'))
        current += self.create_node(UnlexerRule(src='('))
        return current
    LB.min_depth = 0

    @depthcontrol
    def RB(self):
        current = self.create_node(UnlexerRule(name='RB'))
        current += self.create_node(UnlexerRule(src=')'))
        return current
    RB.min_depth = 0

    @depthcontrol
    def LP(self):
        current = self.create_node(UnlexerRule(name='LP'))
        current += self.create_node(UnlexerRule(src='{'))
        return current
    LP.min_depth = 0

    @depthcontrol
    def RP(self):
        current = self.create_node(UnlexerRule(name='RP'))
        current += self.create_node(UnlexerRule(src='}'))
        return current
    RP.min_depth = 0

    @depthcontrol
    def LS(self):
        current = self.create_node(UnlexerRule(name='LS'))
        current += self.create_node(UnlexerRule(src='['))
        return current
    LS.min_depth = 0

    @depthcontrol
    def RS(self):
        current = self.create_node(UnlexerRule(name='RS'))
        current += self.create_node(UnlexerRule(src=']'))
        return current
    RS.min_depth = 0

    # @depthcontrol
    def SEMI(self):
        current = self.create_node(UnlexerRule(name='SEMI'))
        current += self.create_node(UnlexerRule(src=';\n'))
        return current
    SEMI.min_depth = 0

    # @depthcontrol
    def COLON(self):
        current = self.create_node(UnlexerRule(name='COLON'))
        current += self.create_node(UnlexerRule(src=':'))
        return current
    COLON.min_depth = 0

    # @depthcontrol
    def COMMA(self):
        current = self.create_node(UnlexerRule(name='COMMA'))
        current += self.create_node(UnlexerRule(src=','))
        return current
    COMMA.min_depth = 0

    @depthcontrol
    def DOT(self):
        current = self.create_node(UnlexerRule(name='DOT'))
        current += self.create_node(UnlexerRule(src='.'))
        return current
    DOT.min_depth = 0

    @depthcontrol
    def STR_CHAR(self):
        current = self.create_node(UnlexerRule(name='STR_CHAR'))
        current += UnlexerRule(src=self.char_from_list(charset_4))
        return current
    STR_CHAR.min_depth = 0

    @depthcontrol
    def ESCSEQ(self):
        current = self.create_node(UnlexerRule(name='ESCSEQ'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_80', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_80', choice)] = self.unlexer.weights.get(('alt_80', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=r'\\b'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=r'\\f'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src=r'\\r'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src=r'\\n'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src=r'\\t'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src=r'\\\''))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src=r'\\\\'))
        elif choice == 7:
            current += self.create_node(UnlexerRule(src=r'\\"'))
        return current
    ESCSEQ.min_depth = 0

    # @depthcontrol
    # def ESCERROR(self):
    #     current = self.create_node(UnlexerRule(name='ESCERROR'))
    #     current += self.create_node(UnlexerRule(src='\\'))
    #     current += UnlexerRule(src=self.char_from_list(charset_5))
    #     return current
    # ESCERROR.min_depth = 0

    # @depthcontrol
    def ID(self, func=None):
        def lotto(threshold=.85):
            current = self.create_node(UnlexerRule(name='ID'))
            if self.betLessThan(threshold):
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_6)))
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_more():
                        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_7)))
                # keyword filter
                if str(current) in ['function', 'break', 'continue', 'if', 'else', 'for', 'while', 'return', 'of', 'do', 'out', 'inherit', 'true', 'false']:
                    current += self.create_node(UnlexerRule(src='1'))
            else:
                current += self.LocalVarID() if self.betLessThan(.5) else self.GlobalFuncID()
            return current

        curr = self.create_node(UnlexerRule(name='ID'))
        if func is None:
            curr += lotto()
        else:
            if self.betLessThan(.7):
                curr += self.InheritParamID(func)
            else:
                curr += lotto()
        
        return curr
    ID.min_depth = 0

    # @depthcontrol
    def LocalVarID(self, typ=None):
        # find a reachable var
        current = self.create_node(UnlexerRule(name='ID'))
        if self.betLessThan(.98): # 98% hit a local var
            varlist = reduce(lambda x,y: x+list(y.items()), self.vstack, [])
            if len(varlist) == 0:
                current += self.ID()
            else:
                if typ is not None:
                    temp = list(filter(lambda x: type(x[1]) == type(typ), varlist))
                    if len(temp) != 0:
                         varlist = temp
                ind = np.random.randint(len(varlist))
                current += self.create_node(UnlexerRule(src=varlist[ind][0]))
        else:
            current += self.ID()
        return current

    # @depthcontrol
    def GlobalFuncID(self):
        current = self.create_node(UnlexerRule(name='ID'))
        if self.betLessThan(.98): # 98% hit a global func
            funcset = list(self.fstack.keys())
            if self.betLessThan(.7):
                ind = np.random.randint(10,len(funcset))
            else:
                ind = np.random.randint(0,10)
            current += self.create_node(UnlexerRule(src=funcset[ind]))
        else:
            current += self.ID()
        return current
    
    def InheritParamID(self, func):
        current = self.create_node(UnlexerRule(name='ID'))
        if self.betLessThan(.98): # 98% hit an inherited parameter
            parent = self.getfun(func)
            if parent is None: 
                current += self.ID()
            else:
                params = list(filter(lambda x: x.name is not None, parent.partype))
                if len(params) != 0:
                    ind = np.random.randint(len(params))
                    current += self.create_node(UnlexerRule(src=params[ind].name))
                else:
                    current += self.ID()
        else:
            current += self.ID()
        return current

    @depthcontrol
    def WS(self):
        current = self.create_node(UnlexerRule(name='WS'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_8)))

        return current
    WS.min_depth = 0

    # @depthcontrol
    # def ERROR_CHAR(self):
    #     current = self.create_node(UnlexerRule(name='ERROR_CHAR'))
    #     current += UnlexerRule(src=self.any_char())
    #     raise ErrorToken(self.text)
    #     return current
    # ERROR_CHAR.min_depth = 0

    # @depthcontrol
    # def UNCLOSE_STRING(self):
    #     current = self.create_node(UnlexerRule(name='UNCLOSE_STRING'))
    #     current += self.create_node(UnlexerRule(src='"'))
    #     if self.unlexer.max_depth >= 1:
    #         for _ in self.zero_or_more():
    #             choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_102', i), 1) for i, w in enumerate([1, 1])])
    #             self.unlexer.weights[('alt_102', choice)] = self.unlexer.weights.get(('alt_102', choice), 1) * self.unlexer.cooldown
    #             if choice == 0:
    #                 current += self.unlexer.STR_CHAR()
    #             elif choice == 1:
    #                 current += self.unlexer.ESCSEQ()

    #     choice = self.choice([0 if [1, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_105', i), 1) for i, w in enumerate([1, 1])])
    #     self.unlexer.weights[('alt_105', choice)] = self.unlexer.weights.get(('alt_105', choice), 1) * self.unlexer.cooldown
    #     if choice == 0:
    #         current += self.unlexer.EOF()
    #     elif choice == 1:
    #         current += self.create_node(UnlexerRule(src='\n'))
        
    #     	content = str(self.text)
    #     	esc = '\n'
    #     	if content[-1] in esc:
    #     		raise UncloseString(content[1:-1])
    #     	else:
    #     		raise UncloseString(content[1:])
    #     return current
    # UNCLOSE_STRING.min_depth = 0

    # @depthcontrol
    # def ILLEGAL_ESCAPE(self):
    #     current = self.create_node(UnlexerRule(name='ILLEGAL_ESCAPE'))
    #     current += self.create_node(UnlexerRule(src='"'))
    #     if self.unlexer.max_depth >= 1:
    #         for _ in self.zero_or_more():
    #             choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_112', i), 1) for i, w in enumerate([1, 1])])
    #             self.unlexer.weights[('alt_112', choice)] = self.unlexer.weights.get(('alt_112', choice), 1) * self.unlexer.cooldown
    #             if choice == 0:
    #                 current += self.unlexer.STR_CHAR()
    #             elif choice == 1:
    #                 current += self.unlexer.ESCSEQ()

    #     current += self.unlexer.ESCERROR()
        
    #     	content = str(self.text) 
    #     	raise IllegalEscape(content[1:])
    #     return current
    # ILLEGAL_ESCAPE.min_depth = 1

