# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import MT22UnlexerChecker
import numpy as np
from TypeInference import *


class MT22UnparserChecker(Grammarinator):

    def __init__(self, unlexer):
        super(MT22UnparserChecker, self).__init__()
        self.unlexer = unlexer

    def betLessThan(self, threshold):
        # threshold from 0 -> 1
        throw = np.random.rand()
        return True if throw < threshold else False

    def transform(self, typ: str):
        if typ == 'integer':
            return IntegerType()
        elif typ == 'float':
            return FloatType()
        elif typ == 'boolean':
            return BooleanType()
        elif typ == 'string':
            return StringType()
        elif typ == 'auto':
            return AutoType()
        elif typ == 'void':
            return VoidType()
        elif 'array' in typ:
            dims, typ = typ[6:typ.find(']')].replace('_','').split(','), typ[typ.find(']')+3:]
            return ArrayType([int(dim) for dim in dims], self.transform(typ))

    @depthcontrol
    def program(self):
        # local ctx
        self.local_ctx = dict()
        self.local_ctx['iSize'] = 0
        
        current = self.create_node(UnparserRule(name='program'))
        current += self.defaultFunc()
        current += self.vardecl() # to ensure that we have some variables
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.decl()

        current += self.unlexer.EOF()
        return current
    program.min_depth = 4

    @depthcontrol
    def decl(self):
        current = self.create_node(UnparserRule(name='decl'))
        choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_116', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_116', choice)] = self.unlexer.weights.get(('alt_116', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.vardecl()
        elif choice == 1:
            current += self.funcdecl()
        return current
    decl.min_depth = 3

    @depthcontrol
    def vardecl(self):
        current = self.create_node(UnparserRule(name='vardecl'))

        idlist = self.idlist()
        current += idlist
        idlist = str(idlist).split(',')

        current += self.unlexer.COLON()

        typ = self.typ()
        current += typ
        typ = self.transform(str(typ))
        list(map(lambda x: self.unlexer.addvar(x, typ), idlist))

        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                current += self.unlexer.ASSIGN()
                current += self.param()

        current += self.unlexer.SEMI()
        return current
    vardecl.min_depth = 2

    @depthcontrol
    def idlist(self):
        # declare iSize
        self.local_ctx['iSize'] = 1

        current = self.create_node(UnparserRule(name='idlist'))
        current += self.unlexer.ID()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.unlexer.ID()
                # change local_ctx to self.local_ctx
                self.local_ctx['iSize'] += 1

        return current
    idlist.min_depth = 1

    def defaultFunc(self):
        # foo
        current = self.create_node(UnparserRule(name='funcdecl'))
        current += self.create_node(UnlexerRule(src='foo'))
        current += self.unlexer.COLON()
        current += self.unlexer.Function()
        current += self.unlexer.VOID()
        current += self.unlexer.LB()

        current += self.unlexer.Inherit()
        current += self.unlexer.Out()
        current += self.create_node(UnlexerRule(src='a'))
        current += self.unlexer.COLON()
        current += self.unlexer.INTEGER()
        current += self.unlexer.COMMA()

        current += self.unlexer.Inherit()
        current += self.unlexer.Out()
        current += self.create_node(UnlexerRule(src='b'))
        current += self.unlexer.COLON()
        current += self.unlexer.STRING()
        current += self.unlexer.RB()

        current += self.unlexer.LP()
        current += self.unlexer.RP()

        # bar
        current += self.create_node(UnparserRule(name='funcdecl'))
        current += self.create_node(UnlexerRule(src='bar'))
        current += self.unlexer.COLON()
        current += self.unlexer.Function()
        current += self.unlexer.INTEGER()
        current += self.unlexer.LB()

        current += self.unlexer.Inherit()
        current += self.unlexer.Out()
        current += self.unlexer.create_node(UnlexerRule(src='x'))
        current += self.unlexer.COLON()
        current += self.unlexer.INTEGER()

        current += self.unlexer.COMMA()

        current += self.unlexer.Inherit()
        current += self.unlexer.Out()
        current += self.unlexer.create_node(UnlexerRule(src='y'))
        current += self.unlexer.COLON()
        current += self.unlexer.BOOLEAN()

        current += self.unlexer.RB()

        current += self.unlexer.LP()
        current += self.unlexer.RP()
        
        return current

    @depthcontrol
    def funcdecl(self):
        self.unlexer.vstack.append({})

        current = self.create_node(UnparserRule(name='funcdecl'))

        newnode = self.unlexer.ID()
        current += newnode

        current += self.unlexer.COLON()
        current += self.unlexer.Function()
        choice = self.choice([0 if [2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_123', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_123', choice)] = self.unlexer.weights.get(('alt_123', choice), 1) * self.unlexer.cooldown

        if choice == 0:
            ret = self.typ()
            current += ret
        elif choice == 1:
            ret = self.unlexer.VOID()
            current += ret

        current += self.unlexer.LB()

        inherited = parent = None
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                inherited = self.unlexer.Inherit()
                parent = self.unlexer.GlobalFuncID()

        partype = []
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                params = self.paramlist(str(parent))
                current += params
                params = str(params)
                params = params.split(',')
                i = 0 # merge array type
                while i < len(params):
                    if 'array' in params[i]:
                        j = i-1
                        merge = []
                        while(']of' not in params[j+1]): 
                            j+=1
                            merge.append(params[j])
                        j += 1
                        merge.append(params[j])
                        params[i] = ','.join(merge)
                        del params[i+1:j+1]
                    i += 1
                # print(params)
                for param in params:
                    inherit, out = False, False
                    if 'inherit' in param:
                        param = param[7:]
                        inherit = True
                    if 'out' in param:
                        param = param[3:]
                        out = True
                    name, typ = param.split(':')
                    partype.append(ParamType(self.transform(typ), out, inherit, name))

        current += self.unlexer.RB()
        if inherited is not None:
            current += inherited
            current += parent 
            # take inherited params
            parent = self.unlexer.getfun(str(parent))
            if parent is not None:
                for param in parent.partype:
                    if param.inherit is True:
                        self.unlexer.addvar(param.name, param)

        self.unlexer.addfun(str(newnode), FuncType(partype, self.transform(str(ret)), inherited))
        
        current += self.blockstmt(partype if inherited is not None else None)
        self.unlexer.vstack.pop()
        return current
    funcdecl.min_depth = 2
        
    def supercall(self, parlist):
        def enc(typ):
            if isinstance(typ, IntegerType):
                return getattr(self.unlexer, 'INTLIT')()
            elif isinstance(typ, FloatType):
                return getattr(self.unlexer, 'FLOATLIT')()
            elif isinstance(typ, BooleanType):
                return getattr(self.unlexer, 'BOOLLIT')()
            elif isinstance(typ, StringType):
                return getattr(self.unlexer, 'STRLIT')()
            elif isinstance(typ, AutoType):
                return getattr(self, 'expr')(typ)[0]
            elif isinstance(typ, ArrayType):
                return getattr(self, 'index_arrlit')()[0]

        current = self.create_node(UnparserRule(name='callstmt'))

        if self.betLessThan(.2):
            current += self.create_node(UnlexerRule(src='preventDefault'))
            current += self.unlexer.LB()
            current += self.unlexer.RB()
            current += self.unlexer.SEMI()
            return current
        
        if len(parlist) == 0 and self.betLessThan(.2):
            # implicit call
            return self.callstmt()
        
        current += self.create_node(UnlexerRule(src='super'))
        current += self.unlexer.LB()
        
        if len(parlist) != 0:
            current += enc(parlist[0].partype)
            for par in parlist[1:]:
                current += self.unlexer.COMMA()
                current += enc(par.partype)

        current += self.unlexer.RB()
        current += self.unlexer.SEMI()
        return current
        

    @depthcontrol
    def paramlist(self, func=None):
        current = self.create_node(UnparserRule(name='paramlist'))
        current += self.paramdecl(func)
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.paramdecl(func)

        return current
    paramlist.min_depth = 3

    @depthcontrol
    def paramdecl(self, func=None):
        current = self.create_node(UnparserRule(name='paramdecl'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Inherit()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Out()

        current += self.unlexer.ID(func)
        current += self.unlexer.COLON()
        current += self.typ()
        return current
    paramdecl.min_depth = 2

    @depthcontrol
    def stmt(self):
        current = self.create_node(UnparserRule(name='stmt'))
        choice = self.choice([0 if [6, 6, 6, 6, 6, 2, 2, 2, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_131', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_131', choice)] = self.unlexer.weights.get(('alt_131', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.assignstmt()
        elif choice == 1:
            current += self.ifstmt()
        elif choice == 2:
            current += self.forstmt()
        elif choice == 3:
            current += self.whilestmt()
        elif choice == 4:
            current += self.dowhilestmt()
        elif choice == 5:
            current += self.breakstmt()
        elif choice == 6:
            current += self.continuestmt()
        elif choice == 7:
            current += self.returnstmt()
        elif choice == 8:
            current += self.callstmt()
        elif choice == 9:
            current += self.blockstmt()
        return current
    stmt.min_depth = 2

    @depthcontrol
    def assignstmt(self):
        current = self.create_node(UnparserRule(name='assignstmt'))
        current += self.scalarVar()
        current += self.unlexer.ASSIGN()
        current += self.expr()[0]
        current += self.unlexer.SEMI()
        return current
    assignstmt.min_depth = 5

    @depthcontrol
    def ifstmt(self):
        current = self.create_node(UnparserRule(name='ifstmt'))
        current += self.unlexer.If()
        current += self.unlexer.LB()
        current += self.expr()[0]
        current += self.unlexer.RB()
        current += self.stmt()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.Else()
                current += self.stmt()

        return current
    ifstmt.min_depth = 5

    @depthcontrol
    def forstmt(self):
        current = self.create_node(UnparserRule(name='forstmt'))
        current += self.unlexer.For()
        current += self.unlexer.LB()
        current += self.scalarVar()
        current += self.unlexer.ASSIGN()
        current += self.expr()[0]
        current += self.unlexer.COMMA()
        current += self.expr()[0]
        current += self.unlexer.COMMA()
        current += self.expr()[0]
        current += self.unlexer.RB()
        current += self.stmt()
        return current
    forstmt.min_depth = 5

    @depthcontrol
    def scalarVar(self):
        current = self.create_node(UnparserRule(name='scalarVar'))
        choice = self.choice([0 if [7, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_143', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_143', choice)] = self.unlexer.weights.get(('alt_143', choice), 1) * self.unlexer.cooldown

        if choice == 0:
            current += self.index_expr()[0]
        elif choice == 1:
            current += self.unlexer.LocalVarID()
        return current
    scalarVar.min_depth = 1

    @depthcontrol
    def whilestmt(self):
        current = self.create_node(UnparserRule(name='whilestmt'))
        current += self.unlexer.While()
        current += self.unlexer.LB()
        current += self.expr()[0]
        current += self.unlexer.RB()
        current += self.stmt()
        return current
    whilestmt.min_depth = 5

    @depthcontrol
    def dowhilestmt(self):
        current = self.create_node(UnparserRule(name='dowhilestmt'))
        current += self.unlexer.Do()
        current += self.blockstmt()
        current += self.unlexer.While()
        current += self.unlexer.LB()
        current += self.expr()[0]
        current += self.unlexer.RB()
        current += self.unlexer.SEMI()
        return current
    dowhilestmt.min_depth = 5

    @depthcontrol
    def breakstmt(self):
        current = self.create_node(UnparserRule(name='breakstmt'))
        current += self.unlexer.Break()
        current += self.unlexer.SEMI()
        return current
    breakstmt.min_depth = 1

    @depthcontrol
    def continuestmt(self):
        current = self.create_node(UnparserRule(name='continuestmt'))
        current += self.unlexer.Continue()
        current += self.unlexer.SEMI()
        return current
    continuestmt.min_depth = 1

    @depthcontrol
    def returnstmt(self):
        current = self.create_node(UnparserRule(name='returnstmt'))
        current += self.unlexer.Return()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.expr()[0]

        current += self.unlexer.SEMI()
        return current
    returnstmt.min_depth = 1

    @depthcontrol
    def callstmt(self):
        current = self.create_node(UnparserRule(name='callstmt'))
        current += self.funcall()[0]
        current += self.unlexer.SEMI()
        return current
    callstmt.min_depth = 2

    @depthcontrol
    def blockstmt(self, parlist=None):
        current = self.create_node(UnparserRule(name='blockstmt'))
        current += self.unlexer.LP()
        if self.unlexer.max_depth >= 3:
            if parlist is not None and self.betLessThan(.95):
                current += self.supercall(parlist)
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_148', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_148', choice)] = self.unlexer.weights.get(('alt_148', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.stmt()
                elif choice == 1:
                    current += self.vardecl()

        current += self.unlexer.RP()
        return current
    blockstmt.min_depth = 1

    @depthcontrol
    def typ(self):
        current = self.create_node(UnparserRule(name='typ'))
        choice = self.choice([0 if [2, 3, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_151', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_151', choice)] = self.unlexer.weights.get(('alt_151', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.atomic()
        elif choice == 1:
            current += self.arrtype()
        elif choice == 2:
            current += self.unlexer.AUTO()
        return current
    typ.min_depth = 1

    @depthcontrol
    def atomic(self):
        current = self.create_node(UnparserRule(name='atomic'))
        choice = self.choice([0 if [1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_155', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_155', choice)] = self.unlexer.weights.get(('alt_155', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.BOOLEAN()
        elif choice == 1:
            current += self.unlexer.INTEGER()
        elif choice == 2:
            current += self.unlexer.FLOAT()
        elif choice == 3:
            current += self.unlexer.STRING()
        return current
    atomic.min_depth = 1

    @depthcontrol
    def arrtype(self):
        current = self.create_node(UnparserRule(name='arrtype'))
        current += self.unlexer.ARRAY()
        current += self.unlexer.LS()
        current += self.unlexer.INTLIT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.unlexer.INTLIT()

        current += self.unlexer.RS()
        current += self.unlexer.Of()
        current += self.atomic()
        return current
    arrtype.min_depth = 2

    @depthcontrol
    def literal(self, typ=None):
        def controlChoice(choice, typ):
            if typ is None:
                return choice
            if isinstance(typ, StringType):
                wrong = [0,1,2,4]
                correct = 3
            elif isinstance(typ, IntegerType):
                wrong = [1,2,3,4]
                correct = 0
            elif isinstance(typ, FloatType):
                wrong = [0,2,3,4]
                correct = 1
            elif isinstance(typ, FloatType):
                wrong = [0,1,3,4]
                correct = 2
            else:
                wrong = [0,1,2,3]
                correct = 4
            return correct if self.betLessThan(.9) else wrong[np.random.randint(4)]
        
        current = self.create_node(UnparserRule(name='literal'))
        choice = self.choice([0 if [1, 3, 2, 1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_161', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_161', choice)] = self.unlexer.weights.get(('alt_161', choice), 1) * self.unlexer.cooldown
        
        choice = controlChoice(choice, typ)
        if choice == 0:
            current += self.unlexer.INTLIT()
            newtyp = IntegerType()
        elif choice == 1:
            current += self.unlexer.FLOATLIT()
            newtyp = FloatType()
        elif choice == 2:
            current += self.unlexer.BOOLLIT()
            newtyp = BooleanType()
        elif choice == 3:
            current += self.unlexer.STRLIT()
            newtyp = StringType()
        elif choice == 4:
            node, newtyp = self.index_arrlit()
            current += node
        return current, newtyp
    literal.min_depth = 1

    @depthcontrol
    def index_arrlit(self):
        current = self.create_node(UnparserRule(name='index_arrlit'))
        current += self.unlexer.LP()
        typ, size = None, 0
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                node, typ = self.expr()
                current += node
                size = 1
                if self.unlexer.max_depth >= 5:
                    for _ in range(np.random.randint(4)):
                        current += self.unlexer.COMMA()
                        current += self.expr(typ)[0]
                        size += 1

        current += self.unlexer.RP()

        if typ is None:
            newtyp = ArrayType([size], None)
        elif isinstance(typ, ArrayType):
            newtyp = ArrayType([size]+typ.dimensions, typ.typ)
        else:
            newtyp = typ
        return current, newtyp
    index_arrlit.min_depth = 1

    @depthcontrol
    def operands(self, typ=None):
        def controlChoice(choice, typ):
            if typ is None:
                return choice
            if self.betLessThan(.3):
                return 0
            if self.betLessThan(3/7):
                return 2
            if self.betLessThan(1/2):
                return 3
            return 1 if self.betLessThan(.5) else 4

        current = self.create_node(UnparserRule(name='operands'))
        choice = self.choice([0 if [2, 7, 1, 2, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_169', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_169', choice)] = self.unlexer.weights.get(('alt_169', choice), 1) * self.unlexer.cooldown

        choice = controlChoice(choice,typ)
        if choice == 0:
            node, newtyp = self.literal(typ)
            current += node
        elif choice == 1:
            node, newtyp = self.index_expr()
            current += node
        elif choice == 2:
            current += self.unlexer.LocalVarID(typ)
            newtyp = typ
        elif choice == 3:
            node, newtyp = self.funcall()
            current += node
        elif choice == 4:
            current += self.unlexer.LB()

            node, newtyp = self.expr(typ)
            current += node

            current += self.unlexer.RB()
        return current, newtyp
    operands.min_depth = 1

    @depthcontrol
    def funcall(self):
        current = self.create_node(UnparserRule(name='funcall'))

        node = self.unlexer.GlobalFuncID()
        current += node
        newtyp = self.unlexer.getfun(str(node))

        current += self.unlexer.LB()
        if newtyp is None:
            current += self.unlexer.RB()
            return current, None

        params = newtyp.partype
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                # current += self.param()
                size = len(params) if self.betLessThan(.9) else np.random.randint(len(params)+3)

                current += self.expr(params[0].partype)[0] if len(params) > 0 else self.expr()[0]
                for i in range(1,size):
                    current += self.unlexer.COMMA()
                    current += self.expr(params[i].partype)[0] if len(params) > i else self.expr()[0]

        current += self.unlexer.RB()
        
        return current, newtyp.rettype
    funcall.min_depth = 1

    @depthcontrol
    def index_expr(self):
        current = self.create_node(UnparserRule(name='index_expr'))

        node = self.unlexer.LocalVarID(ArrayType([0], None))
        current += node
        node = self.unlexer.getvar(str(node))

        current += self.unlexer.LS()

        params = self.param()
        current += params 
        count = len(str(params).split(','))

        if not isinstance(node, ArrayType):
            newtyp = node
        else:
            if count == len(node.dimensions):
                newtyp = node.typ
            elif count < len(node.dimensions):
                newtyp = ArrayType(node.dimensions[count:], node.typ)
            else:
                newtyp = node        

        current += self.unlexer.RS()
        return current, newtyp
    index_expr.min_depth = 6

    @depthcontrol
    def param(self, typ=None):
        current = self.create_node(UnparserRule(name='param'))
        current += self.expr(typ)[0]
        if self.unlexer.max_depth >= 5:
            # change looptime
            looptime = range(self.local_ctx['iSize']-1) if self.local_ctx['iSize'] > 0 else self.zero_or_more()
            for _ in looptime:
                current += self.unlexer.COMMA()
                current += self.expr(typ)[0]
                # local_ctx['pSize'] += 1
            # reset iSize
            self.local_ctx['iSize'] = 0
        return current
    param.min_depth = 5

    @depthcontrol
    def expr(self, typ=None):
        def controlChoice(choice, typ):
            if typ is None:
                return 0 if self.betLessThan(.8) else 1
            if isinstance(typ, StringType):
                return 1 if self.betLessThan(.9) else 0
            return 0 if self.betLessThan(.9) else 1

        current = self.create_node(UnparserRule(name='expr'))
        choice = self.choice([0 if [4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_178', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_178', choice)] = self.unlexer.weights.get(('alt_178', choice), 1) * self.unlexer.cooldown

        choice = controlChoice(choice, typ)
        if choice == 0:
            node, newtyp = self.string_expr(typ)
            current += node

        elif choice == 1:
            newtyp = StringType()
            current += self.string_expr(newtyp)[0]
            current += self.unlexer.CONCAT()
            current += self.string_expr(newtyp)[0]

        return current, newtyp
    expr.min_depth = 4

    @depthcontrol
    def string_expr(self, typ=None):
        def controlChoice(choice, typ):
            if typ is None:
                return 0 if self.betLessThan(.7) else 1
            if isinstance(typ, BooleanType):
                return 1 if self.betLessThan(.5) else 0
            return 0 if self.betLessThan(.9) else 1
        
        current = self.create_node(UnparserRule(name='string_expr'))
        choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_181', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_181', choice)] = self.unlexer.weights.get(('alt_181', choice), 1) * self.unlexer.cooldown

        choice = controlChoice(choice, typ)
        if choice == 0:
            node, newtyp = self.num_expr(typ)
            current += node

        elif choice == 1:
            choice = self.choice([0 if [1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_184', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
            self.unlexer.weights[('alt_184', choice)] = self.unlexer.weights.get(('alt_184', choice), 1) * self.unlexer.cooldown

            if choice == 0 or choice == 1:
                ltyp = BooleanType() if self.betLessThan(.5) else IntegerType()
                rtyp = BooleanType() if self.betLessThan(.5) else IntegerType()
            else:
                ltyp = FloatType() if self.betLessThan(.5) else IntegerType()
                rtyp = FloatType() if self.betLessThan(.5) else IntegerType()

            current += self.num_expr(ltyp)[0]
            if choice == 0:
                current += self.unlexer.NEQ()
            elif choice == 1:
                current += self.unlexer.EQUAL()
            elif choice == 2:
                current += self.unlexer.GRE()
            elif choice == 3:
                current += self.unlexer.GEQ()
            elif choice == 4:
                current += self.unlexer.LES()
            elif choice == 5:
                current += self.unlexer.LEQ()

            current += self.num_expr(rtyp)[0]
            newtyp = BooleanType()

        return current, newtyp
    string_expr.min_depth = 3

    @depthcontrol
    def num_expr(self, typ=None):
        def controlChoice(choice, typ):
            if typ is None:
                return choice
            if isinstance(typ, BooleanType):
                correct = [1,4,5,5,5]
                wrong = [0,2,3]
                guess = correct[np.random.randint(len(correct))] if self.betLessThan(.9)\
                    else wrong[np.random.randint(3)]
                return 5
            if isinstance(typ, IntegerType) or isinstance(typ, FloatType):
                correct = [0,2,3,5,5,5]
                wrong = [1,4]
                guess = correct[np.random.randint(len(correct))] if self.betLessThan(.9)\
                    else wrong[np.random.randint(2)]
                return 5
            return 5 if self.betLessThan(.9) else np.random.randint(5)
        
        current = self.create_node(UnparserRule(name='num_expr'))
        choice = self.choice([0 if [3, 3, 3, 3, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_191', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_191', choice)] = self.unlexer.weights.get(('alt_191', choice), 1) * self.unlexer.cooldown

        choice = controlChoice(choice, typ)
        if choice == 0:
            current += self.unlexer.SUB()
            newtyp = IntegerType() if self.betLessThan(.5) or isinstance(typ, IntegerType) else FloatType()
            current += self.num_expr(newtyp)[0]

        elif choice == 1:
            current += self.unlexer.LNOT()
            newtyp = BooleanType()
            current += self.num_expr(newtyp)[0]

        elif choice == 2:
            newtyp = IntegerType() if self.betLessThan(.5) or isinstance(typ, IntegerType) else FloatType()
            ltyp = IntegerType() if isinstance(newtyp, IntegerType) else IntegerType() if self.betLessThan(.5) else FloatType()
            rtyp = IntegerType() if isinstance(newtyp, IntegerType) else IntegerType() if self.betLessThan(.5) else FloatType()

            current += self.num_expr(ltyp)[0]
            choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_198', i), 1) for i, w in enumerate([1, 1, 1])])
            self.unlexer.weights[('alt_198', choice)] = self.unlexer.weights.get(('alt_198', choice), 1) * self.unlexer.cooldown

            if choice == 0:
                current += self.unlexer.MUL()
            elif choice == 1:
                current += self.unlexer.MOD()
            elif choice == 2:
                current += self.unlexer.DIV()
                newtyp = IntegerType()
            current += self.num_expr(rtyp)[0]

        elif choice == 3:
            newtyp = IntegerType() if self.betLessThan(.5) or isinstance(typ, IntegerType) else FloatType()
            ltyp = IntegerType() if isinstance(newtyp, IntegerType) else IntegerType() if self.betLessThan(.5) else FloatType()
            rtyp = IntegerType() if isinstance(newtyp, IntegerType) else IntegerType() if self.betLessThan(.5) else FloatType()

            current += self.num_expr(ltyp)[0]

            choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_202', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_202', choice)] = self.unlexer.weights.get(('alt_202', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.SUB()
            elif choice == 1:
                current += self.unlexer.ADD()

            current += self.num_expr(rtyp)[0]

        elif choice == 4:
            newtyp = BooleanType()
            current += self.num_expr(newtyp)[0]

            choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_205', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_205', choice)] = self.unlexer.weights.get(('alt_205', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.LAND()
            elif choice == 1:
                current += self.unlexer.LOR()

            current += self.num_expr(newtyp)[0]

        elif choice == 5:
            node, newtyp = self.operands(typ)
            current += node

        return current, newtyp
    num_expr.min_depth = 2

    default_rule = program

