# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import MT22Unlexer


class MT22Unparser(Grammarinator):

    def __init__(self, unlexer):
        super(MT22Unparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def program(self):
        # local ctx
        self.local_ctx = dict()
        self.local_ctx['iSize'] = 0
        
        current = self.create_node(UnparserRule(name='program'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.decl()

        current += self.unlexer.EOF()
        return current
    program.min_depth = 4

    @depthcontrol
    def decl(self):
        current = self.create_node(UnparserRule(name='decl'))
        choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_116', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_116', choice)] = self.unlexer.weights.get(('alt_116', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.vardecl()
        elif choice == 1:
            current += self.funcdecl()
        return current
    decl.min_depth = 3

    @depthcontrol
    def vardecl(self):
        current = self.create_node(UnparserRule(name='vardecl'))
        current += self.idlist()
        current += self.unlexer.COLON()
        current += self.typ()
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                current += self.unlexer.ASSIGN()
                current += self.param()
                
                # if local_ctx['idlist'].iSize > local_ctx['param'].pSize:
                #     raise NoViableAltException(self)
                # elif local_ctx['idlist'].iSize < local_ctx['param'].pSize:
                #     raise NoViableAltException(self, offendingToken=local_ctx['param'].ctx.COMMA(local_ctx['idlist'].iSize-1).getPayload())

        current += self.unlexer.SEMI()
        return current
    vardecl.min_depth = 2

    @depthcontrol
    def idlist(self):
        # declare iSize
        self.local_ctx['iSize'] = 1

        current = self.create_node(UnparserRule(name='idlist'))
        current += self.unlexer.ID()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.unlexer.ID()
                # change local_ctx to self.local_ctx
                self.local_ctx['iSize'] += 1

        return current
    idlist.min_depth = 1

    @depthcontrol
    def funcdecl(self):
        current = self.create_node(UnparserRule(name='funcdecl'))
        current += self.unlexer.ID()
        current += self.unlexer.COLON()
        current += self.unlexer.Function()
        choice = self.choice([0 if [2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_123', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_123', choice)] = self.unlexer.weights.get(('alt_123', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.typ()
        elif choice == 1:
            current += self.unlexer.VOID()
        current += self.unlexer.LB()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.paramlist()

        current += self.unlexer.RB()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Inherit()
                current += self.unlexer.ID()

        current += self.blockstmt()
        return current
    funcdecl.min_depth = 2

    @depthcontrol
    def paramlist(self):
        current = self.create_node(UnparserRule(name='paramlist'))
        current += self.paramdecl()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.paramdecl()

        return current
    paramlist.min_depth = 3

    @depthcontrol
    def paramdecl(self):
        current = self.create_node(UnparserRule(name='paramdecl'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Inherit()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Out()

        current += self.unlexer.ID()
        current += self.unlexer.COLON()
        current += self.typ()
        return current
    paramdecl.min_depth = 2

    @depthcontrol
    def stmt(self):
        current = self.create_node(UnparserRule(name='stmt'))
        choice = self.choice([0 if [6, 6, 6, 6, 6, 2, 2, 2, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_131', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_131', choice)] = self.unlexer.weights.get(('alt_131', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.assignstmt()
        elif choice == 1:
            current += self.ifstmt()
        elif choice == 2:
            current += self.forstmt()
        elif choice == 3:
            current += self.whilestmt()
        elif choice == 4:
            current += self.dowhilestmt()
        elif choice == 5:
            current += self.breakstmt()
        elif choice == 6:
            current += self.continuestmt()
        elif choice == 7:
            current += self.returnstmt()
        elif choice == 8:
            current += self.callstmt()
        elif choice == 9:
            current += self.blockstmt()
        return current
    stmt.min_depth = 2

    @depthcontrol
    def assignstmt(self):
        current = self.create_node(UnparserRule(name='assignstmt'))
        current += self.scalarVar()
        current += self.unlexer.ASSIGN()
        current += self.expr()
        current += self.unlexer.SEMI()
        return current
    assignstmt.min_depth = 5

    @depthcontrol
    def ifstmt(self):
        current = self.create_node(UnparserRule(name='ifstmt'))
        current += self.unlexer.If()
        current += self.unlexer.LB()
        current += self.expr()
        current += self.unlexer.RB()
        current += self.stmt()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.Else()
                current += self.stmt()

        return current
    ifstmt.min_depth = 5

    @depthcontrol
    def forstmt(self):
        current = self.create_node(UnparserRule(name='forstmt'))
        current += self.unlexer.For()
        current += self.unlexer.LB()
        current += self.scalarVar()
        current += self.unlexer.ASSIGN()
        current += self.expr()
        current += self.unlexer.COMMA()
        current += self.expr()
        current += self.unlexer.COMMA()
        current += self.expr()
        current += self.unlexer.RB()
        current += self.stmt()
        return current
    forstmt.min_depth = 5

    @depthcontrol
    def scalarVar(self):
        current = self.create_node(UnparserRule(name='scalarVar'))
        choice = self.choice([0 if [7, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_143', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_143', choice)] = self.unlexer.weights.get(('alt_143', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.index_expr()
        elif choice == 1:
            current += self.unlexer.ID()
        return current
    scalarVar.min_depth = 1

    @depthcontrol
    def whilestmt(self):
        current = self.create_node(UnparserRule(name='whilestmt'))
        current += self.unlexer.While()
        current += self.unlexer.LB()
        current += self.expr()
        current += self.unlexer.RB()
        current += self.stmt()
        return current
    whilestmt.min_depth = 5

    @depthcontrol
    def dowhilestmt(self):
        current = self.create_node(UnparserRule(name='dowhilestmt'))
        current += self.unlexer.Do()
        current += self.blockstmt()
        current += self.unlexer.While()
        current += self.unlexer.LB()
        current += self.expr()
        current += self.unlexer.RB()
        current += self.unlexer.SEMI()
        return current
    dowhilestmt.min_depth = 5

    @depthcontrol
    def breakstmt(self):
        current = self.create_node(UnparserRule(name='breakstmt'))
        current += self.unlexer.Break()
        current += self.unlexer.SEMI()
        return current
    breakstmt.min_depth = 1

    @depthcontrol
    def continuestmt(self):
        current = self.create_node(UnparserRule(name='continuestmt'))
        current += self.unlexer.Continue()
        current += self.unlexer.SEMI()
        return current
    continuestmt.min_depth = 1

    @depthcontrol
    def returnstmt(self):
        current = self.create_node(UnparserRule(name='returnstmt'))
        current += self.unlexer.Return()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.expr()

        current += self.unlexer.SEMI()
        return current
    returnstmt.min_depth = 1

    @depthcontrol
    def callstmt(self):
        current = self.create_node(UnparserRule(name='callstmt'))
        current += self.funcall()
        current += self.unlexer.SEMI()
        return current
    callstmt.min_depth = 2

    @depthcontrol
    def blockstmt(self):
        current = self.create_node(UnparserRule(name='blockstmt'))
        current += self.unlexer.LP()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_148', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_148', choice)] = self.unlexer.weights.get(('alt_148', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.stmt()
                elif choice == 1:
                    current += self.vardecl()

        current += self.unlexer.RP()
        return current
    blockstmt.min_depth = 1

    @depthcontrol
    def typ(self):
        current = self.create_node(UnparserRule(name='typ'))
        choice = self.choice([0 if [2, 3, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_151', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_151', choice)] = self.unlexer.weights.get(('alt_151', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.atomic()
        elif choice == 1:
            current += self.arrtype()
        elif choice == 2:
            current += self.unlexer.AUTO()
        return current
    typ.min_depth = 1

    @depthcontrol
    def atomic(self):
        current = self.create_node(UnparserRule(name='atomic'))
        choice = self.choice([0 if [1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_155', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_155', choice)] = self.unlexer.weights.get(('alt_155', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.BOOLEAN()
        elif choice == 1:
            current += self.unlexer.INTEGER()
        elif choice == 2:
            current += self.unlexer.FLOAT()
        elif choice == 3:
            current += self.unlexer.STRING()
        return current
    atomic.min_depth = 1

    @depthcontrol
    def arrtype(self):
        current = self.create_node(UnparserRule(name='arrtype'))
        current += self.unlexer.ARRAY()
        current += self.unlexer.LS()
        current += self.unlexer.INTLIT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.unlexer.INTLIT()

        current += self.unlexer.RS()
        current += self.unlexer.Of()
        current += self.atomic()
        return current
    arrtype.min_depth = 2

    @depthcontrol
    def literal(self):
        current = self.create_node(UnparserRule(name='literal'))
        choice = self.choice([0 if [1, 3, 2, 1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_161', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_161', choice)] = self.unlexer.weights.get(('alt_161', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.INTLIT()
        elif choice == 1:
            current += self.unlexer.FLOATLIT()
        elif choice == 2:
            current += self.unlexer.BOOLLIT()
        elif choice == 3:
            current += self.unlexer.STRLIT()
        elif choice == 4:
            current += self.index_arrlit()
        return current
    literal.min_depth = 1

    @depthcontrol
    def index_arrlit(self):
        current = self.create_node(UnparserRule(name='index_arrlit'))
        current += self.unlexer.LP()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.expr()
                if self.unlexer.max_depth >= 5:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.expr()


        current += self.unlexer.RP()
        return current
    index_arrlit.min_depth = 1

    @depthcontrol
    def operands(self):
        current = self.create_node(UnparserRule(name='operands'))
        choice = self.choice([0 if [2, 7, 1, 2, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_169', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_169', choice)] = self.unlexer.weights.get(('alt_169', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.literal()
        elif choice == 1:
            current += self.index_expr()
        elif choice == 2:
            current += self.unlexer.ID()
        elif choice == 3:
            current += self.funcall()
        elif choice == 4:
            current += self.unlexer.LB()
            current += self.expr()
            current += self.unlexer.RB()
        return current
    operands.min_depth = 1

    @depthcontrol
    def funcall(self):
        current = self.create_node(UnparserRule(name='funcall'))
        current += self.unlexer.ID()
        current += self.unlexer.LB()
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                current += self.param()

        current += self.unlexer.RB()
        return current
    funcall.min_depth = 1

    @depthcontrol
    def index_expr(self):
        current = self.create_node(UnparserRule(name='index_expr'))
        current += self.unlexer.ID()
        current += self.unlexer.LS()
        current += self.param()
        current += self.unlexer.RS()
        return current
    index_expr.min_depth = 6

    @depthcontrol
    def param(self):
        current = self.create_node(UnparserRule(name='param'))
        current += self.expr()
        if self.unlexer.max_depth >= 5:
            # change looptime
            looptime = range(self.local_ctx['iSize']-1) if self.local_ctx['iSize'] > 0 else self.zero_or_more()
            for _ in looptime:
                current += self.unlexer.COMMA()
                current += self.expr()
                # local_ctx['pSize'] += 1
            # reset iSize
            self.local_ctx['iSize'] = 0
        return current
    param.min_depth = 5

    @depthcontrol
    def expr(self):
        current = self.create_node(UnparserRule(name='expr'))
        choice = self.choice([0 if [4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_178', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_178', choice)] = self.unlexer.weights.get(('alt_178', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.string_expr()
        elif choice == 1:
            current += self.string_expr()
            current += self.unlexer.CONCAT()
            current += self.string_expr()
        return current
    expr.min_depth = 4

    @depthcontrol
    def string_expr(self):
        current = self.create_node(UnparserRule(name='string_expr'))
        choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_181', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_181', choice)] = self.unlexer.weights.get(('alt_181', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.num_expr()
        elif choice == 1:
            current += self.num_expr()
            choice = self.choice([0 if [1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_184', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
            self.unlexer.weights[('alt_184', choice)] = self.unlexer.weights.get(('alt_184', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.NEQ()
            elif choice == 1:
                current += self.unlexer.EQUAL()
            elif choice == 2:
                current += self.unlexer.GRE()
            elif choice == 3:
                current += self.unlexer.GEQ()
            elif choice == 4:
                current += self.unlexer.LES()
            elif choice == 5:
                current += self.unlexer.LEQ()
            current += self.num_expr()
        return current
    string_expr.min_depth = 3

    @depthcontrol
    def num_expr(self):
        current = self.create_node(UnparserRule(name='num_expr'))
        choice = self.choice([0 if [3, 3, 3, 3, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_191', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_191', choice)] = self.unlexer.weights.get(('alt_191', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SUB()
            current += self.num_expr()
        elif choice == 1:
            current += self.unlexer.LNOT()
            current += self.num_expr()
        elif choice == 2:
            current += self.num_expr()
            choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_198', i), 1) for i, w in enumerate([1, 1, 1])])
            self.unlexer.weights[('alt_198', choice)] = self.unlexer.weights.get(('alt_198', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.MUL()
            elif choice == 1:
                current += self.unlexer.MOD()
            elif choice == 2:
                current += self.unlexer.DIV()
            current += self.num_expr()
        elif choice == 3:
            current += self.num_expr()
            choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_202', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_202', choice)] = self.unlexer.weights.get(('alt_202', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.SUB()
            elif choice == 1:
                current += self.unlexer.ADD()
            current += self.num_expr()
        elif choice == 4:
            current += self.num_expr()
            choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_205', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_205', choice)] = self.unlexer.weights.get(('alt_205', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.LAND()
            elif choice == 1:
                current += self.unlexer.LOR()
            current += self.num_expr()
        elif choice == 5:
            current += self.operands()
        return current
    num_expr.min_depth = 2

    default_rule = program

